# Extracting State Logic into a Reducer - 상태 로직을 Reducer로 추출하기

## 언제 사용하는가?

- 여러 이벤트 핸들러가 상태를 변경시키고, 컴포넌트의 크기가 커지면서 상태 관리 로직이 여러 곳으로 흩어져 있는 경우
- 복잡성을 줄이고 컴포넌트에서 분리된 한 곳에 로직을 모을 수 있음

## 상태 관리 로직을 reducer로 옮기는 법

### 1. setState를 모두 dispatch의 형태로 변경하기

- 모든 상태 설정 로직을 제거
- 해당 이벤트가 사용자가 어떤 이벤트를 발생시킨 것인지를 나타내는 `action`만 남음
- 상태를 설정하는 로직 자체에서 추가, 변경, 삭제 등의 `action`을 `dispatch`하는 로직으로 변경
- 사용자의 의도를 더 잘 드러낼 수 있게 됨
- 컨벤션으로 `action` 객체는 문자열로 된 `type`과 추가적인 정보로 구성됨

### 2. `reducer` 함수 작성하기

- 모든 상태 로직이 위치하는 곳
- reducer에서 반환하는 값을 상태의 값으로 설정
- 인자로 1. 현재 상태 2. `action` 객체를 받음
- 다음 상태(변경된 상태)를 반환
- 컨벤션으로 `switch`문을 이용

### 3. `reducer` 사용하기

- `useReducer`를 사용
- 인자로 1. `reducer` 2. 초기 상태를 받음
- 반환 값으로 1. 상태 값 2. `dispatch` 함수를 반환

## `useState`와 `useReducer`를 비교하기

### 1. 코드 양

- 기본적으로는 `useState`가 양이 더 적음
- `useReducer`는 `reducer` 함수와 `dispatch action`을 모두 작성해야 함
- 하지만 공유하는 로직이 많아지고 유사하게 수정하는 로직이 많아지면 `reducer` 방식이 코드 양을 줄이는 데에 도움이 됨

### 2. 가독성

- useState가 기본적으로는 가독성이 더 뛰어남
- 상태가 복잡해지면 컴포넌트의 크기가 커짐
- `useReducer`는 이 상황에서 깔끔하게 로직을 분리할 수 있도록 도움
- '어떻게' 상태가 업데이트 되는지를 '어떤' 일이 발생했는지에서 분리할 수 있음

### 3. 테스트

- 컴포넌트에 의존적이지 않은 독립된 순수 함수
- export 해서 독립적으로 테스트할 수 있음

### 4. 취향

### 추천 사용 케이스

- 잘못된 상태 업데이트로 인한 버그와 자주 마주할 때
- 컴포넌트에 구조를 더 추가하고 싶을 때

## `reducer`를 잘 쓰는 법

### 1. `reducer`는 순수함수로 작성해야 한다.

### 2. 각 `action`은 한 개의 사용자 상호작용과 대응해야 한다. (데이터에 여러 변경이 발생하더라도)
