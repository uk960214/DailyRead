# Concurrent(동시성) 리액트는 무엇인가

리액트 18에 추가된 가장 중요한 것은 사실 우리는 여러분이 절대로 생각해보지 않았으면 하는 "Concurrency(동시성)"입니다. 우리는 이것이 애플리케이션 개발자들에게는 거의 옳은 일이라고 생각합니다. 라이브러리 관리자들에게는 이것보다는 조금 더 복잡할 것이지만요.

Concurrency는 그 자체로 기능은 아닙니다. Concurrency는 리액트가 당신의 UI의 여러 버전을 동시에 준비할 수 있도록 해주는 무대 뒤 매커니즘입니다. 여러분은 Concurrency를 구현 디테일로 생각하면 됩니다 - 이것은 이를 통해 가능해지는 기능들 때문에 중요합니다. 리액트는 우선순위 큐와 복수 버퍼링 등 내부 구현을 위해서 정교한 기술들을 활용합니다. 이런 개념들은 우리의 공개 API에 어디에서도 찾아볼 수 없죠.

우리는 API를 디자인할 때 개발자들에게 구현 디테일들을 숨기려고 합니다. 리액트 개발자로서 여러분은 _어떤_ 사용자 경험이 보였으면 좋겠는지에 집중하고 그 경험을 _어떻게_ 전달할지는 리액트가 다룹니다. 따라서 우리는 리액트 개발자들이 Concurrency가 어떻게 뒤에서 어떻게 작동하는지 모를 것이라고 생각합니다.

그러나 Concurrent 리액트는 다른 전형적인 구현 디테일보다는 더 중요합니다 - 이는 리액트의 핵심 렌더링 모델의 중추적인 업데이트이기 때문이죠. 따라서 Concurrency가 어떻게 작동하는 지를 아는 것은 아주 중요하지 않을지라도 고차원적으로 이것이 무엇인지를 아는 것은 의미가 있을 지도 모릅니다.

Concurrent 리액트의 핵심 속성은 렌더링을 방해할 수 있다는 점입니다. 여러분이 리액트 18로 가장 처음 업그레이드 했을 때, 그 어떤 Concurrent 기능들을 추가하기 전까지는 업데이트의 렌더링이 이전 버전의 리액트에서와 같이 하나의 방해받지 않는 동기적인 과정입니다. 동기적인 렌더링으로는 업데이트가 렌더링을 시작하면 사용자가 화면에 결과를 보기 전까지는 무엇도 렌더링을 방해할 수 없습니다.

Concurrent 렌더링에서는 이렇게 작동하지 않는 상황도 생깁니다. 리액트는 업데이트를 렌더링을 시작한 뒤 중간에 일시정지 하고 나중에 계속할 수 있습니다. 심지어 진행 중인 렌더링 자체를 중지해버릴 수도 있죠. 리액트는 렌더가 방해받더라도 UI가 일관되게 나타나는 것을 보장합니다. 이를 위해서 리액트는 트리 전체가 평가된 뒤까지 기다린 뒤에 DOM 변형을 실행합니다. 이를 통해서 리액트는 메인 스레드를 방해하지 않으면서 새로운 화면을 뒤에서 준비할 수 있습니다. 이 말은 UI가 큰 렌더링 작업을 실행하는 중에도 사용자의 입력 값에 바로 대응할 수 있어 자연스러운 사용자 경험을 만들어 줄 수 있다는 것을 의미합니다.

또 다른 예시는 재사용가능한 상태입니다. Concurrent 리액트는 스크린에서 UI의 섹션을 제거하고 나중에 과거의 상태를 활용해서 다시 추가할 수 있습니다. 예를 들어 사용자가 특정 화면에서 탭을 옮긴 다음 다시 돌아왔을 때 리액트는 이전의 화면을 이전의 동일한 상태로 복원할 수 있어야 합니다. 곧 있을 소규모 업데이트에서 우리는 이 패턴을 구현한 `<Offscreen>`이라는 요소를 추가할 계획입니다. 앞선 설명과 유사하게 Offscreen을 사용해서 뒤에서 새로운 UI를 준비해서 사용자가 이를 공개하기 전에 이미 준비되어 있도록 할 수 있습니다.

Concurrent 렌더링은 리액트의 새로운 강력한 도구이며 서스펜스, 트랜지션, 스트리밍 서버 렌더링 등 우리의 새로운 기능 대부분이 이를 활용하도록 설계되었습니다. 하지만 리액트 18은 우리가 이 새로운 기반을 토대로 만들고자 하는 목표의 시작에 불과합니다.
